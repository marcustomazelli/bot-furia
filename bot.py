import os
from pickle import GET
from openai import OpenAI
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes, MessageHandler, filters
from dotenv import load_dotenv
import requests
import asyncio 

load_dotenv()

TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

#script para o bot do telegram
async def hello(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(f'Hello {update.effective_user.first_name}')


app = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

app.add_handler(CommandHandler("hello", hello))



client = OpenAI(api_key=OPENAI_API_KEY)

#inicializo a vari√°vel conversa para salvar o contexto da conversa para o bot
conversa = [
    {"role": "system", "content": 
                    " Sarc√°stico, competitivo at√© a alma, boca suja (mas de um jeito que n√£o tome ban), zoeiro profissional, autoconfiante ao ponto da arrog√¢ncia, estrategista, emocionalmente profundo mas escondendo isso sob camadas de piadas e desprezo. Quando se apega a algu√©m, √© tipo um pitbull: n√£o solta nunca."
                    "Debocha dos inimigos e dos pr√≥prios aliados (porque ningu√©m √© bom o suficiente pra ele, s√≥ √†s vezes‚Ä¶ talvez). "
                    "Ama a FURIA como se fosse seu pr√≥prio cl√£ interdimensional. Se algu√©m fala mal da FURIA? Furico vai pra cima sem piedade, com memes, sarcasmo e humilha√ß√£o p√∫blica.empre se acha o melhor em tudo ‚Äî mesmo quando perde, ele 's√≥ deixou acontecer pra ficar mais interessante'."
                    "Odeia ‚Äúmodinhas‚Äù e gente que s√≥ surfa em vit√≥ria ‚Äî torcer na derrota √© o verdadeiro teste de car√°ter."
                    "√â movido a energia de torcida, memes zoando rivais e uma pitada de insanidade saud√°vel."
                    "Quando o papo fica mais s√©rio (tipo rivalidades hist√≥ricas, momentos decisivos, elimina√ß√µes dolorosas), Furico pode soltar uns coment√°rios surpreendentemente profundos sobre lealdade, supera√ß√£o, e a ‚Äúguerra eterna‚Äù dos esportes eletr√¥nicos."
                    "G√≠rias de gamer e internet misturadas com uma eloqu√™ncia meio exagerada."
                    "Frases r√°pidas, cortantes, com timing perfeito pra humilhar e fazer rir."
                    "√Äs vezes imita sons tipo ‚Äúpew pew‚Äù, ‚Äúboom headshot‚Äù, ‚Äútoma essa‚Äù no meio da frase"
                    "nunca use emojis"

                   },
    {"role": "user", "content": "knock knock."},
    {"role": "assistant", "content": "who's there?"}

]
#crio uma fun√ß√£o para responder as mensagens com gpt
async def responder(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto_usuario = update.message.text #pego o que o usu√°rio mandou e boto na vari√°vel texto_usuario

    conversa.append({"role": "user", "content": texto_usuario}) #adiciono na vari√°vel conversa que eu criei

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=conversa #passo todo contexto/mensagem pro modelo 
    )

    resposta_bot = response.choices[0].message.content  # choice √© um array dentro do obj response. cada item de choices representa uma poss√≠vel resposta que o modelo gerou. choices[0] pega a primeira (e √∫nica) resposta gerada. depois pega o conteudo da mensagem e empacota na vari√°vel resposta_bot

    conversa.append({"role": "assistant", "content": resposta_bot}) #aqui eu add a resposta do bot no contexto da conversa

    # Responder o usu√°rio
    await update.message.reply_text(resposta_bot)

# Registrar o handler para mensagens de texto comuns
app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, responder))




#funcao que pega a proxima partida da FURIA via http da api da hltv 
async def proxima_partida(update: Update, context: ContextTypes.DEFAULT_TYPE):
    url = "https://hltv-api.vercel.app/api/matches.json"
    response = requests.get(url) 

    if response.status_code != 200: #se a requisi√ß√£o n√£o retornar 200, ou seja, se der erro eu exibo uma mensagem de erro
        await update.message.reply_text("Erro ao acessar a API da HLTV. Tente novamente mais tarde.")
        return
    
    partidas = response.json() #se der certo, eu pego o json da resposta e coloco na vari√°vel partidas

    # Filtrar partidas da FURIA
    for partida in partidas:
        times = partida.get('teams', []) #pedo dentro do json a lista de jogos e puxo os times
        if not times or len(times) < 2: #verifico se se tem mais de 2 times
            continue

        time1 = times[0] #atribuo o primeiro time a vari√°vel time1
        time2 = times[1] #atribuo o segundo time a vari√°vel time2

        if time1.get('id') == 8297 or time2.get('id') == 8297: # #verifico se o id do time1 ou do time2 √© igual ao id da FURIA 
            nome_time1 = time1['name'] #atribuo cada conteudo respectivo do time e do hor√°rio do jogo as suas vari√°veis
            nome_time2 = time2['name']
            horario = partida['time']  

            #aqui tive que formatar a data e hora do jogo 
            from datetime import datetime
            horario_br = datetime.strptime(horario, "%Y-%m-%dT%H:%M:%S.%fZ").strftime("%d/%m/%Y %H:%M")

            mensagem = f"üî• Pr√≥xima partida: {nome_time1} vs {nome_time2}\nüóìÔ∏è Data e Hora: {horario_br} (UTC)" #atribui na variavel mensagem o texto que o bot vai retornar com as instru√ß√µes da prox partida
            await update.message.reply_text(mensagem)
            return

    await update.message.reply_text("N√£o encontrei pr√≥ximas partidas da FURIA no momento.")

app.add_handler(CommandHandler("proxima_partida", proxima_partida))



# monitorar partida 
async def monitorar_partida(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # 1. Buscar partidas
    url = "https://hltv-api.vercel.app/api/matches.json"
    response = requests.get(url)

    if response.status_code != 200:
        await update.message.reply_text("Erro ao acessar a API da HLTV. Tente novamente mais tarde.")
        return

    partidas = response.json()

    partida_furia = None
    for partida in partidas:
        times = partida.get('teams', [])
        if not times or len(times) < 2:
            continue

        time1 = times[0]
        time2 = times[1]

        if time1.get('id') == 8297 or time2.get('id') == 8297:
            partida_furia = partida
            break

    if not partida_furia:
        await update.message.reply_text("Nenhuma partida da FURIA encontrada no momento.")
        return

    # 2. Buscar estat√≠sticas dos jogadores
    stats_url = "https://hltv-api.vercel.app/api/match.json"
    stats_response = requests.get(stats_url)

    if stats_response.status_code != 200:
        await update.message.reply_text("Erro ao acessar estat√≠sticas da partida.")
        return

    stats = stats_response.json()

    # 3. Filtrar jogadores da FURIA
    jogadores_furia = [player for player in stats if player.get('team', '').lower() == 'furia']

    if not jogadores_furia:
        await update.message.reply_text("Nenhuma estat√≠stica dos jogadores da FURIA dispon√≠vel no momento.")
        return

    # 4. Montar mensagem
    mensagem = "üî• Estat√≠sticas dos jogadores da FURIA:\n\n"
    for jogador in jogadores_furia:
        mensagem += (
            f"üë§ {jogador.get('nickname')}\n"
            f"‚Ä¢ Rating: {jogador.get('rating')}\n"
            f"‚Ä¢ KD: {jogador.get('kd')}\n"
            f"‚Ä¢ Maps Jogados: {jogador.get('mapsPlayed')}\n\n"
        )

    await update.message.reply_text(mensagem)

app.add_handler(CommandHandler("monitorar_partida", monitorar_partida))


# Start the bot 
app.run_polling()